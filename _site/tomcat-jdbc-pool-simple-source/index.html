<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="author" content="闷骚乔巴" />
  <meta name="description" content="闷骚乔巴的博客" /> 
  <title>
    
      tomcat-jdbc-pool 实现简单分析 &middot; 闷骚乔巴
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="/public/css/io.css">
    <link rel="stylesheet" href="http://fonts.lug.ustc.edu.cn/css?family=PT+Serif:400,400italic,700|PT+Sans:400,400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- GA -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-63143391-1', 'auto');
    ga('send', 'pageview');

  </script>
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p><a href="http://kuang.io" target="_blank">闷骚乔巴</a> （闷骚IT男）</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">主页</a>

    

    
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about.html">About</a>
        
      
    
      
    
      
    
      
        
      
    
      
        
      
    

    <a class="sidebar-nav-item" href="https://github.com/chopperkuang">GitHub project</a>
    <span class="sidebar-nav-item">Currently v1.0.0</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2015. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">闷骚乔巴</a>
            <small></small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">tomcat-jdbc-pool 实现简单分析</h1>
  <span class="post-date">2015-05-22</span>
  <p>在现稍微大一点的软件系统开发中，都会接触到池。有时，并不是没有用到，而是没有去注意到。例如：内存池，线程池，连接池等各种各样的池（pool）。</p>

<h3 id="section">先聊聊池</h3>

<p>池，不由自主的会想到水池。  <br />
小时候，我们都要去远处的水井挑水，倒进家中的水池里面。这样，每次要用水时，直接从水池中“取”就行了。不用大老远跑去水井打水。</p>

<p>数据库连接池就如此，我们预先准备好一些连接，放到池中。当需要时，就直接获取。而不要每次跟数据库建立一个新的连接。特别对数据库连接这类耗时，耗资源的操作。当连接用完后，再放回池中，供后续使用。</p>

<p>从上可以简单看些，池的一些基本特征：  <br />
。池会有一定的容量，及已经创建好的对象  <br />
。有“借”有“还”操作的接口</p>

<p>我先前有简单看过dbcp，c3po连接池的实现。相对于简单，精湛tomcat-jdbc-pool，还是复杂不少。<br />
tomcat-jdbc-pool基于jdk1.5后的线程池实现。所以你懂得。</p>

<h3 id="section-1">有借有还，再借不难</h3>
<p>俗话说：“有借有还，再借不难”。<br />
我们刨去各种初始化，各种花枝招展的包装以及一些简单逻辑的卫语句。直接去看看tomcat-jdbc-pool是怎么管理“借”的操作。<br />
<code>org.apache.tomcat.jdbc.pool.ConnectionPool borrowConnection()</code></p>

<p><img src="http://kuang.io/images/posts/20150524-tomcat-jdbc-pool-borrowConnection-2.png" alt="image" /></p>

<h3 id="section-2">借了后怎么还</h3>
<p>在连接池中，是不会去关闭真实的数据库连接的。只将归还至可用的池中。  <br />
如果真实关闭数据库连接了，那连接池的又有什么用咧。。。</p>

<p><img src="http://kuang.io/images/posts/20150524-tomcat-jdbc-pool-returnConnection.png" alt="image" /></p>

<h3 id="section-3">清除不良账务</h3>
<p>当访问高峰过时，我们会创建不少新的连接。   <br />
高峰过后，我们需要去清理可能暂不再会使用的连接，释放些资源。（如有需要，可再创建嘛。有借有还，这再借当然不难落。）   <br />
<em>不用去找那么多类，连接的管理都在<code>ConnectionPool</code>中。</em>     <br />
<code>PoolCleaner extends TimerTask</code>   <br />
在池的初始化时就进行注册，内部采用<code>scheduleAtFixedRate</code>方式，定时扫描<code>idle</code>队列中所有的空闲连接，进行释放（当然每个连接有标志其创建和最后将使用完成的时间。通过这些时间判断是否可以释放了）。</p>

<h4 id="section-4">贴源码</h4>
<p>技术文章写得比较少，正在不断练习中。  <br />
还是直接贴源码，这些源码注释还不错，最好的技术文档了。有空可以多去读读。</p>

<h4 id="borrowconnection">borrowConnection</h4>
<pre><code class="language-java">/**
 * Thread safe way to retrieve a connection from the pool
 * @param wait - time to wait, overrides the maxWait from the properties,
 * set to -1 if you wish to use maxWait, 0 if you wish no wait time.
 * @return PooledConnection
 * @throws SQLException
 */
private PooledConnection borrowConnection(int wait, String username, String password) throws SQLException {

    if (isClosed()) {
        throw new SQLException("Connection pool closed.");
    } //end if

    //get the current time stamp
    long now = System.currentTimeMillis();
    //see if there is one available immediately
    PooledConnection con = idle.poll();

    while (true) {
        if (con!=null) {
            //configure the connection and return it
            PooledConnection result = borrowConnection(now, con, username, password);
            //null should never be returned, but was in a previous impl.
            if (result!=null) return result;
        }

        //if we get here, see if we need to create one
        //this is not 100% accurate since it doesn't use a shared
        //atomic variable - a connection can become idle while we are creating
        //a new connection
        if (size.get() &lt; getPoolProperties().getMaxActive()) {
            //atomic duplicate check
            if (size.addAndGet(1) &gt; getPoolProperties().getMaxActive()) {
                //if we got here, two threads passed through the first if
                size.decrementAndGet();
            } else {
                //create a connection, we're below the limit
                return createConnection(now, con, username, password);
            }
        } //end if

        //calculate wait time for this iteration
        long maxWait = wait;
        //if the passed in wait time is -1, means we should use the pool property value
        if (wait==-1) {
            maxWait = (getPoolProperties().getMaxWait()&lt;=0)?Long.MAX_VALUE:getPoolProperties().getMaxWait();
        }

        long timetowait = Math.max(0, maxWait - (System.currentTimeMillis() - now));
        waitcount.incrementAndGet();
        try {
            //retrieve an existing connection
            con = idle.poll(timetowait, TimeUnit.MILLISECONDS);
        } catch (InterruptedException ex) {
            if (getPoolProperties().getPropagateInterruptState()) {
                Thread.currentThread().interrupt();
            } else {
                Thread.interrupted();
            }
            SQLException sx = new SQLException("Pool wait interrupted.");
            sx.initCause(ex);
            throw sx;
        } finally {
            waitcount.decrementAndGet();
        }
        if (maxWait==0 &amp;&amp; con == null) { //no wait, return one if we have one
        if (jmxPool!=null) {
            jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.POOL_EMPTY, "Pool empty - no wait.");
            }
            throw new PoolExhaustedException("[" + Thread.currentThread().getName()+"] " +
                    "NoWait: Pool empty. Unable to fetch a connection, none available["+busy.size()+" in use].");
        }
        //we didn't get a connection, lets see if we timed out
        if (con == null) {
            if ((System.currentTimeMillis() - now) &gt;= maxWait) {
                if (jmxPool!=null) {
                    jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.POOL_EMPTY, "Pool empty - timeout.");
                }
                throw new PoolExhaustedException("[" + Thread.currentThread().getName()+"] " +
                    "Timeout: Pool empty. Unable to fetch a connection in " + (maxWait / 1000) +
                    " seconds, none available[size:"+size.get() +"; busy:"+busy.size()+"; idle:"+idle.size()+"; lastwait:"+timetowait+"].");
            } else {
                //no timeout, lets try again
                continue;
            }
        }
    } //while
}
</code></pre>

<h4 id="returnconnection">returnConnection</h4>
<pre><code class="language-java">/**
 * Returns a connection to the pool
 * If the pool is closed, the connection will be released
 * If the connection is not part of the busy queue, it will be released.
 * If {@link PoolProperties#testOnReturn} is set to true it will be validated
 * @param con PooledConnection to be returned to the pool
 */
protected void returnConnection(PooledConnection con) {
    if (isClosed()) {
        //if the connection pool is closed
        //close the connection instead of returning it
        release(con);
        return;
    } //end if

    if (con != null) {
        try {
            con.lock();

            if (busy.remove(con)) {

                if (!shouldClose(con,PooledConnection.VALIDATE_RETURN)) {
                    con.setStackTrace(null);
                    con.setTimestamp(System.currentTimeMillis());
                    if (((idle.size()&gt;=poolProperties.getMaxIdle()) &amp;&amp; !poolProperties.isPoolSweeperEnabled()) || (!idle.offer(con))) {
                        if (log.isDebugEnabled()) {
                            log.debug("Connection ["+con+"] will be closed and not returned to the pool, idle["+idle.size()+"]&gt;=maxIdle["+poolProperties.getMaxIdle()+"] idle.offer failed.");
                        }
                        release(con);
                    }
                } else {
                    if (log.isDebugEnabled()) {
                        log.debug("Connection ["+con+"] will be closed and not returned to the pool.");
                    }
                    release(con);
                } //end if
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("Connection ["+con+"] will be closed and not returned to the pool, busy.remove failed.");
                }
                release(con);
            }
        } finally {
            con.unlock();
        }
    } //end if
} //checkIn
</code></pre>

<h4 id="checkidle">checkIdle</h4>
<pre><code class="language-java">public void checkIdle(boolean ignoreMinSize) {

    try {
        if (idle.size()==0) return;
        long now = System.currentTimeMillis();
        Iterator&lt;PooledConnection&gt; unlocked = idle.iterator();
        while ( (ignoreMinSize || (idle.size()&gt;=getPoolProperties().getMinIdle())) &amp;&amp; unlocked.hasNext()) {
            PooledConnection con = unlocked.next();
            boolean setToNull = false;
            try {
                con.lock();
                //the con been taken out, we can't clean it up
                if (busy.contains(con))
                    continue;
                long time = con.getTimestamp();
                if (shouldReleaseIdle(now, con, time)) {
                    release(con);
                    idle.remove(con);
                    setToNull = true;
                } else {
                    //do nothing
                } //end if
            } finally {
                con.unlock();
                if (setToNull)
                    con = null;
            }
        } //while
    } catch (ConcurrentModificationException e) {
        log.debug("checkIdle failed." ,e);
    } catch (Exception e) {
        log.warn("checkIdle failed, it will be retried.",e);
    }

}


protected boolean shouldReleaseIdle(long now, PooledConnection con, long time) {
    if (con.getConnectionVersion() &lt; getPoolVersion()) return true;
    else return (con.getReleaseTime()&gt;0) &amp;&amp; ((now - time) &gt; con.getReleaseTime()) &amp;&amp; (getSize()&gt;getPoolProperties().getMinIdle());
}

private static volatile Timer poolCleanTimer = null;
private static HashSet&lt;PoolCleaner&gt; cleaners = new HashSet&lt;&gt;();

private static synchronized void registerCleaner(PoolCleaner cleaner) {
    unregisterCleaner(cleaner);
    cleaners.add(cleaner);
    if (poolCleanTimer == null) {
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        try {
            Thread.currentThread().setContextClassLoader(ConnectionPool.class.getClassLoader());
            poolCleanTimer = new Timer("PoolCleaner["+ System.identityHashCode(ConnectionPool.class.getClassLoader()) + ":"+
                                       System.currentTimeMillis() + "]", true);
        }finally {
            Thread.currentThread().setContextClassLoader(loader);
        }
    }
    poolCleanTimer.scheduleAtFixedRate(cleaner, cleaner.sleepTime,cleaner.sleepTime);
}

private static synchronized void unregisterCleaner(PoolCleaner cleaner) {
    boolean removed = cleaners.remove(cleaner);
    if (removed) {
        cleaner.cancel();
        if (poolCleanTimer != null) {
            poolCleanTimer.purge();
            if (cleaners.size() == 0) {
                poolCleanTimer.cancel();
                poolCleanTimer = null;
            }
        }
    }
}

protected static class PoolCleaner extends TimerTask {
    protected WeakReference&lt;ConnectionPool&gt; pool;
    protected long sleepTime;
    protected volatile long lastRun = 0;

    PoolCleaner(ConnectionPool pool, long sleepTime) {
        this.pool = new WeakReference&lt;&gt;(pool);
        this.sleepTime = sleepTime;
        if (sleepTime &lt;= 0) {
            log.warn("Database connection pool evicter thread interval is set to 0, defaulting to 30 seconds");
            this.sleepTime = 1000 * 30;
        } else if (sleepTime &lt; 1000) {
            log.warn("Database connection pool evicter thread interval is set to lower than 1 second.");
        }
    }

    @Override
    public void run() {
        ConnectionPool pool = this.pool.get();
        if (pool == null) {
            stopRunning();
        } else if (!pool.isClosed() &amp;&amp;
                (System.currentTimeMillis() - lastRun) &gt; sleepTime) {
            lastRun = System.currentTimeMillis();
            try {
                if (pool.getPoolProperties().isRemoveAbandoned())
                    pool.checkAbandoned();
                if (pool.getPoolProperties().getMinIdle() &lt; pool.idle
                        .size())
                    pool.checkIdle();
                if (pool.getPoolProperties().isTestWhileIdle())
                    pool.testAllIdle();
            } catch (Exception x) {
                log.error("", x);
            }
        }
    }

    public void start() {
        registerCleaner(this);
    }

    public void stopRunning() {
        unregisterCleaner(this);
    }
}
</code></pre>


</div>

<div id="disqus_container">
    <div id="disqus_thread"></div>
</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/self-management-by-drucker">
            管理自己—《哈佛商业评论》重印次数最多的文章之一
            <small>2015-03-02</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/management-X-and-Y">
            管理思维启蒙的X,Y,Z理念
            <small>2015-01-13</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/not-break-cohesive-team">
            不要拆散洋基队
            <small>2015-01-10</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'kuangio';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
